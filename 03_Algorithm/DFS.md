# 🚀 깊이우선탐색(DFS)
## 1. 그래프 탐색 알고리즘
- 그래프 자료구조는 `탐색` 알고리즘에 활용됨
- 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘
- 해당 알고리즘엔 (1) 깊이우선탐색(DFS), (2) 너비우선탐색(BFS)가 있음
  - DFS: 스택 + 그래프
  - BFS: 큐 + 그래프

## 2. 깊이우선탐색(Depth-First Search)
- 시작 정점부터 갈 수 있는 하위 정점까지 가장 깊게 탐색하고, 더이상 갈 데가 없으면 가장 인접한 상위 정점으로 돌아와서 또 다른 하위 인접 정점을 탐색하는 등 모든 정점을 순회하는 방법
- 모든 정점 방문 때 유리
  - `경우의 수`, `순열과 조합` 문제에서 많이 사용
- BFS에 비해 코드 구현이 간단함
  - 단, 모든 정점을 방문할 필요가 없거나, 최단 거리를 구하는 경우는 BFS로

## 3. DFS 동작 과정
1. 탐색을 진행할 그래프 필요
    - 인접 행렬
    - 인접 리스트
2. 각 정점 **방문 여부를 확인**할 체크리스트 필요
3. 정점 방문처리
4. 스택에 값 삽입
5. 스택의 마지막 값 꺼내고 인접 정점 확인
6. 방문하지 않은 인접정점 있을 경우 -> 3번으로 회귀
7. 더이상 스택이 없다면 종료

## 4. DFS 구현 방식
```python
# 1. 그래프 만들기
graph = [
  [1, 2],
  [0, 3, 4],
  [0, 4, 5],
  [1],
  [1, 2, 6],
  [2],
  [4]
]

n = len(graph) # 정점의 개수

# 2. 체크리스트(방문여부확인용) 만들기
visited = [False] * n

start = 0 # 시작 정점(예시: 0)
stack = [start] # 돌아갈 정점 기록
visited[start] = True # 시작 정점 방문 처리

while stack: # 스택이 빌 때까지 반복(돌아갈 정점이 없을 때 까지)
  cur = stack.pop() # 현 방문 정점
  for adj in graph[cur]: # 인접한 모든 정점에 대해
    if not visited[adj]: # 미방문 인접 정점인 경우 (False인 경우)
      visited[adj] = True # 방문 처리
      stack.append(adj) # 스택에 해당 인접 정점을 추가함.
```

## 5. 이차원 격자에서의 DFS
> 델타검색부터 복습할 필요가 있다.
## 99. 참고 문제
[BOJ 바이러스 문제](https://www.acmicpc.net/problem/2606)